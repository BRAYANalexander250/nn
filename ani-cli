#!/bin/sh

# dependencies: grep sed curl jq video_player
# video_player ( needs to be able to play urls )
player_fn="mpv"

prog="ani-cli"
logfile="${XDG_CACHE_HOME:-$HOME/.cache}/ani-hsts"
sources='{"name": "gogoanime", "url": "https://www1.gogoanime.cm"}
{"name": "tenshi", "url": "https://tenshi.moe"}'

c_red="\033[1;31m"
c_green="\033[1;32m"
c_yellow="\033[1;33m"
c_blue="\033[1;34m"
c_magenta="\033[1;35m"
c_cyan="\033[1;36m"
c_reset="\033[0m"

menu_format_string='[%d] %s\n'
menu_format_string_c1="${c_blue}[$c_cyan%d$c_blue] $c_reset%s\n"
menu_format_string_c2="${c_blue}[$c_cyan%d$c_blue] $c_yellow%s$c_reset\n"


help_text () {
	while IFS= read -r line; do
		printf "%s\n" "$line"
	done <<-EOF
	USAGE: $prog <query>
	 -h	 show this help text
	 -d	 download episode
	 -H	 continue where you left off
	 -D	 delete history
	 -q	 set video quality (best/worst/360/480/720/..)
	 --dub  play the dub version if present
	EOF
}


die () {
	printf "$c_red%s$c_reset\n" "$*" >&2
	exit 1
}

err () {
	printf "$c_red%s$c_reset\n" "$*" >&2
}

dep_ch () {
	for dep; do
		if ! command -v "$dep" >/dev/null ; then
			die "Program \"$dep\" not found. Please install it."
		fi
	done
}

# select source
source_selection() {
	source_names=$(printf '%s' "$sources" | jq --raw-output '.name')

	count=1
	while read -r source_name; do
		# alternating colors for menu
		[ $((count % 2)) -eq 0 ] &&
			menu_format_string=$menu_format_string_c1 ||
			menu_format_string=$menu_format_string_c2

		printf "$menu_format_string" "$count" "$source_name"
		count=$((count+1))
	done <<-EOF
	$source_names
	EOF

	# user input
	printf "$c_blue%s$c_green" "Enter number: "
	read -r choice
	printf "$c_reset"

	# check if input is a number and greater than 0
	[ "$choice" -eq "$choice" ] 2>/dev/null || die "Invalid number entered"
	[ "$choice" -gt 0 ] 2>/dev/null || die "Invalid number entered"

	# select respective source
	choice=$((choice-1))
	selection=$(printf '%s' "$sources" | jq --slurp ".[$choice] // empty")
	[ -z "$selection" ] && die "Invalid number entered"

	# use source
	base_url=$(printf '%s' "$selection" | jq --raw-output '.url')
	source_name=$(printf '%s' "$selection" | jq --raw-output '.name')
	$source_name
}

# get query
get_search_query () {
	if [ -z "$*" ]; then
		printf "Search Anime: "
		read -r query
	else
		query=$*
	fi
}

# create history file
[ -f "$logfile" ] || : > "$logfile"

#####################
## Anime selection ##
#####################

anime_selection () {
	anime=$*
	anime_names=$(printf '%s' "$search_results" | jq --raw-output '.name')

	count=1
	while read -r anime_name; do
		# alternating colors for menu
		[ $((count % 2)) -eq 0 ] &&
			menu_format_string=$menu_format_string_c1 ||
			menu_format_string=$menu_format_string_c2

		printf "$menu_format_string" "$count" "$anime_name"
		count=$((count+1))
	done <<-EOF
	$anime_names
	EOF

	# User input
	printf "$c_blue%s$c_green" "Enter number: "
	read -r choice
	printf "$c_reset"

	# check if input is a number and greater than 0
	[ "$choice" -eq "$choice" ] 2>/dev/null || die "Invalid number entered"
	[ "$choice" -gt 0 ] 2>/dev/null || die "Invalid number entered"

	# select respective anime
	choice=$((choice-1))
	selection=$(printf '%s' "$anime" | jq --slurp ".[$choice] // empty")
	[ -z "$selection" ] && die "Invalid number entered"

	# use anime
	anime_id=$(printf '%s' "$selection" | jq --raw-output '.id')
	anime_name=$(printf '%s' "$selection" | jq --raw-output '.name')
	last_ep_number=$(get_episode_count "$anime_id")
}

##################
## Ep selection ##
##################

episode_selection() {
	ep_choice_start="1"
	if [ "$last_ep_number" -gt 1 ] 
	then
		[ "$is_download" -eq 1 ] &&
			printf "Range of episodes can be specified: start_number end_number\n"

		printf "${c_blue}Choose episode ${c_cyan}[1-%d]$c_reset:$c_green " "$last_ep_number"
		read -r ep_choice_start ep_choice_end
		printf "$c_reset"
	fi
}

check_input() {
	[ "$ep_choice_start" -eq "$ep_choice_start" ] 2>/dev/null || die "Invalid number entered"
	episodes=$ep_choice_start
	if [ -n "$ep_choice_end" ]; then
		[ "$ep_choice_end" -eq "$ep_choice_end" ] 2>/dev/null || die "Invalid number entered"
		# create list of episodes to download/watch
		episodes=$(seq "$ep_choice_start" "$ep_choice_end")
	fi
}

append_history() {
	entry=$(printf '{"source": "%s", "name": "%s", "id": "%s", "next_ep": %d}' "$source_name" "$anime_name" "$anime_id" $((episode+1)))
	grep -q "\b${source_name}\b.*\b${anime_id}\b" "$logfile" ||
		printf "$entry\n" >> "$logfile"
}

open_selection() {
	for ep in $episodes
	do
		open_episode "$anime_id" "$ep"
	done
	episode=${ep_choice_end:-$ep_choice_start}
}

open_episode () {
	anime_id=$1
	episode=$2

	# Cool way of clearing screen
	tput reset
	while [ "$episode" -lt 1 ] || [ "$episode" -gt "$last_ep_number" ]
	do
		err "Episode out of range"
		printf "${c_blue}Choose episode ${c_cyan}[1-%d]$c_reset:$c_green " "$last_ep_number"
		read -r episode
		printf "$c_reset"
	done

	printf "Getting data for episode %d\n" "$episode"

	video_content=$(get_video_url "$anime_id" "$episode")

	if [ "$is_download" -eq 0 ]; then
		# update episode number
		sed -E '
			s|(\b'"$source_name"'\b.*\b'"$anime_id"'\b.*\bnext_ep\b\": )[^}]*|\1'$((episode+1))'|
		' "$logfile" > "${logfile}.new" && mv "${logfile}.new" "$logfile"

		play_video "$video_content"
	else
		printf "Downloading episode %d ...\n" "$episode"
		download_video "$video_content"
	fi
}


#############
## Sources ##
#############

# gogoanime
gogoanime() {
	search_anime () {
		# get anime name along with its id
		search=$(printf '%s' "$1" | tr ' ' '-' )

		curl -s "$base_url/search.html" \
			-G \
			-d "keyword=$search" |
		sed -n -E '
			s_^[[:space:]]*<a href="/category/([^"]*)" title="([^"]*)".*_{"id": "\1", "name": "\2"}_p
			'
	}

	get_episode_count () {
		anime_id=$1

		curl -s "$base_url/category/$anime_id" |
		sed -n -E '
			/^[[:space:]]*<a href="#" class="active" ep_start/{
			s/.* '\''([0-9]*)'\'' ep_end = '\''([0-9]*)'\''.*/\2/p
			q
			}
			'
	}

	get_video_url () {
		# get the download page url
		anime_id=$1
		ep_no=$2

		# credits to fork: https://github.com/Dink4n/ani-cli for the fix
		# dub prefix takes the value "-dub" when dub is needed else is empty
		embed_url=$(
			curl -s "$base_url/$anime_id${dub_prefix}-episode-$ep_no" |
			sed -n -E '
				/^[[:space:]]*<a href="#" rel="100"/{
				s/.*data-video="([^"]*)".*/https:\1/p
				q
				}'
		)

		video_url=$(
			curl -s "$embed_url" |
			sed -n -E '
				/^[[:space:]]*sources:/{
				s/.*(https[^'\'']*).*/\1/p
				q
				}
				'
		)
		tmp_url=$(printf '%s' "$video_url" | sed -n -E 's/(.*)\.([0-9]+\.[0-9]+)\.[0-9]+\.m3u8/\1.\2.m3u8/p')
		[ -z "$tmp_url" ] || video_url="$tmp_url"

		video_file=$(curl -s --referer "$embed_url" "$video_url")
		available_qualities=$(printf '%s' "$video_file" | sed -n -E 's/.*NAME="([^p]*)p"/\1/p')
		get_video_quality() {
			case $quality in
				best)
					printf '%s' "$available_qualities" | tail -n 1
					;;

				worst)
					printf '%s' "$available_qualities" | head -n 1
					;;

				*)
					is_quality_avail=$(printf '%s' "$available_qualities" | grep "$quality")
					video_quality="$quality"
					if [ -z "$is_quality_avail" ]; then
						printf "$c_red%s$c_reset\n" "Current video quality is not available (defaulting to highest quality)" >&2
						quality=best
						printf '%s' "$available_qualities" | tail -n 1
					fi
					;;
			esac
		}
		video_quality=$(get_video_quality)

		# Replace the video with highest quality video
		video_url=$(printf '%s' "$video_url" | sed -n -E "s/(.*)\.m3u8/\1.$video_quality.m3u8/p")

		case $video_url in
			*streamtape*)
				# If direct download not available then scrape streamtape.com
				BROWSER=${BROWSER:-firefox}
				printf "scraping streamtape.com\n"
				video_url=$(curl -s "$video_url" | sed -n -E '
					/^<script>document/{
					s/^[^"]*"([^"]*)" \+ '\''([^'\'']*).*/https:\1\2\&dl=1/p
					q
					}
				');;
		esac

		printf '{"video_url": "%s", "embed_url": "%s"}' "$video_url" "$embed_url"
	}

	play_video () {
		embed_url=$(printf '%s' "$1" | jq --raw-output '.embed_url')
		video_url=$(printf '%s' "$1" | jq --raw-output '.video_url')
		setsid -f $player_fn --http-header-fields="Referer: $embed_url" "$video_url" >/dev/null 2>&1
	}

	download_video () {
		embed_url=$(printf '%s' "$1" | jq --raw-output '.embed_url')
		video_url=$(printf '%s' "$1" | jq --raw-output '.video_url')
		
		printf "%s\n" "$video_url"
		episode=$(printf "%03d" "$episode")
		{
			ffmpeg -headers "Referer: $embed_url" -i "$video_url" \
				-c copy "${anime_id}-${episode}.mkv" >/dev/null 2>&1 &&
				printf "${c_green}Downloaded episode: %s${c_reset}\n" "$episode" ||
				printf "${c_red}Download failed episode: %s${c_reset}\n" "$episode"
		}
	}
}

# Tenshi
tenshi() {
	search_anime () {
		search=$(printf '%s' "$1" | tr ' ' '+' )
		curl --silent --get --data "q=$search" "$base_url/anime" |
		sed --silent -E 's|^<a href="https://tenshi.moe/anime/([^"]*)" data-toggle="popover" title="([^"]*)".*|{"id": "\1", "name": "\2"}|p'
	}

	get_episode_count () {
		id=$1
		curl --silent --get "$base_url/anime/$id" |
		sed --silent -E 's|^<h2 class="mb-3">Episodes.[^0-9]*([0-9]*).*|\1|p'
	}

	get_video_url () {
		episode_url=$base_url/anime/$1/$2
		embed_url=$(
			curl --silent --get "$episode_url" |
			sed --silent -E 's|^<iframe src="([^"]*)".*|\1|p'
		)
		video_html=$(curl --silent --referer "$episode_url" "$embed_url")

		# get qualities from video_html
		qualities=$(
			printf '%s' "$video_html" |
			sed --silent -E 'N;N; s|.*src:[^h]*([^'"'"']*).*size: ([^,]*).*|{"url": "\1", "quality": "\2"}|p ;D' |
			jq --slurp .
		)

		# get video url for selected quality from qualities
		get_video_quality_url() {
			case $quality in
				best)
					printf '%s' "$qualities" | jq --raw-output '.[0].url'
					;;

				worst)
					printf '%s' "$qualities" | jq --raw-output '.[-1].url'
					;;

				*)
					quality_url=$(printf '%s' "$qualities" | jq --raw-output '.[] | select(.quality == "'$quality'") | .url // empty')
					if [ -z "$quality_url" ]; then
						printf "Current video quality is not available (defaulting to highest quality)" >&2
						quality=best
						printf '%s' "$qualities" | jq --raw-output '.[0].url'
					fi
					printf '%s' "$quality_url"
					;;
			esac
		}
		video_url=$(get_video_quality_url)

		printf '{"video_url": "%s"}' "$video_url"
	}

	play_video () {
		video_url=$(printf '%s' "$1" | jq --raw-output '.video_url')
		setsid -f $player_fn "$video_url" >/dev/null 2>&1
	}

	download_video () {
		embed_url=$(printf '%s' "$1" | jq --raw-output '.embed_url')
		video_url=$(printf '%s' "$1" | jq --raw-output '.video_url')
		
		printf "%s\n" "$video_url"
		episode=$(printf "%03d" "$episode")
		{
			ffmpeg -headers "Referer: $embed_url" -i "$video_url" \
				-c copy "${anime_name}-${episode}.mkv" >/dev/null 2>&1 &&
				printf "${c_green}Downloaded episode: %s${c_reset}\n" "$episode" ||
				printf "${c_red}Download failed episode: %s${c_reset}\n" "$episode"
		}
	}
}

############
# Start Up #
############

# to clear the colors when exited using SIGINT
trap "printf '$c_reset'" INT HUP

dep_ch "$player_fn" "curl" "sed" "grep" "jq"

# option parsing
is_download=0
quality=best
scrape=query
while getopts 'hdHDq:-:' OPT; do
	case $OPT in
		h)
			help_text
			exit 0
			;;
		d)
			is_download=1
			;;
		H)
			scrape=history
			;;

		D)
			: > "$logfile"
			exit 0
			;;
		q)
			quality=$OPTARG
			;;
		-)
			case $OPTARG in
				dub)
					dub_prefix="-dub"
					;;
			esac
			;;
	esac
done
shift $((OPTIND - 1))

########
# main #
########

source_selection

case $scrape in
	query)
		get_search_query "$*"
		search_results=$(search_anime "$query")
		[ -z "$search_results" ] && die "No search results found"
		anime_selection "$search_results"
		episode_selection
		;;
	history)
		search_results=$(jq --raw-input --raw-output 'fromjson? | . | select(.source == "'"$source_name"'")' "$logfile")
		[ -z "$search_results" ] && die "History is empty for $source_name"
		anime_selection "$search_results"
		ep_choice_start=$(jq --raw-input --raw-output 'fromjson? | . | select(.source == "'"$source_name"'" and .id == "'"$anime_id"'") | .next_ep' "$logfile")
		;;
esac

check_input
append_history
open_selection

while :; do
	printf "\n${c_green}Currently playing ${c_cyan}%s ${c_green}episode ${c_cyan}%d/%d\n" "$anime_name" "$episode" "$last_ep_number"
	if [ "$episode" -ne "$last_ep_number" ]; then
		printf "${c_blue}[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "n" "next episode"
	fi
	if [ "$episode" -ne "1" ]; then
		printf "${c_blue}[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "p" "previous episode"
	fi
	if [ "$last_ep_number" -ne "1" ]; then
		printf "${c_blue}[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "s" "select episode"
	fi
	printf "${c_blue}[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "r" "replay current episode"
	printf "${c_blue}[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "a" "search for another anime"
	printf "${c_blue}[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "h" "search history"
	printf "${c_blue}[${c_cyan}%s$c_blue] $c_red%s$c_reset\n" "q" "exit"
	printf "${c_blue}Enter choice:${c_green} "
	read -r choice
	printf "$c_reset"
	case $choice in
		n)
			episode=$((episode + 1))
			;;
		p)
			episode=$((episode - 1))
			;;

		s)	printf "${c_blue}Choose episode ${c_cyan}[1-%d]$c_reset:$c_green " "$last_ep_number"
			read -r episode
			printf "$c_reset"
			[ "$episode" -eq "$episode" ] 2>/dev/null || die "Invalid number entered"
			;;

		r)
			episode=$((episode))
			;;
		a)
			tput reset
			get_search_query ""
			search_results=$(search_anime "$query")
			[ -z "$search_results" ] && die "No search results found"
			anime_selection "$search_results"
			episode_selection
			check_input
			append_history
			open_selection
			continue
			;;
		h)
			tput reset
			search_results=$(jq --raw-input --raw-output 'fromjson? | . | select(.source == "'"$source_name"'")' "$logfile")
			[ -z "$search_results" ] && die "History is empty"
			anime_selection "$search_results"
			ep_choice_start=$(jq --raw-input --raw-output 'fromjson? | . | select(.source == "'"$source_name"'" and .id == "'"$anime_id"'") | .next_ep' "$logfile")
			check_input
			append_history
			open_selection
			continue
			;;

		q)
			break;;

		*)
			die "invalid choice"
			;;
	esac

	open_episode "$anime_id" "$episode"
done